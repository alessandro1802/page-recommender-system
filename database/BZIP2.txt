free open-source file compression program us burrows–wheeler algorithm compress single file file archiver developed julian seward maintained mark wielaard micah snyder seward made first public release version july the compressor stability popularity grew next several year seward released version late verified body following nine-year hiatus update project since june federico mena accepted maintainership project since june maintainer micah snyder us several layer compression technique stacked top occur following order compression reverse order decompression any sequence consecutive duplicate symbol replaced first symbol repeat length thus sequence aaaaaaabbbbcccd replaced represent byte value respectively run symbol always transformed consecutive symbol even run-length set zero keep transformation reversible worst case cause expansion best case reduction while specification theoretically allows run length encoded reference encoder produce output the author stated rle step historical mistake intended protect original bwt implementation pathological case the burrows–wheeler transform reversible block-sort core the block entirely self-contained input output buffer remaining size—in operating limit stage for block-sort notional matrix created row contains whole buffer rotated start i-th symbol following rotation row matrix sorted alphabetic numerical order pointer stored marking starting position block untransformed practice necessary construct full matrix rather sort performed using pointer position buffer the output buffer last column matrix contains whole buffer reordered likely contain large run identical symbol the move-to-front transform alter size processed block each symbol use document placed array when symbol processed replaced location index array symbol shuffled front array the effect immediately recurring symbol replaced zero symbol long run arbitrary symbol thus become run zero symbol symbol remapped according local frequency much natural data contains identical symbol recur within limited range text good example mtf transform assigns low value symbol reappear frequently result data stream containing many symbol low integer range many identical different recurring input symbol actually map output symbol such data efficiently encoded legacy compression method long string zero output move-to-front transform come repeated symbol output bwt replaced sequence two special code runa runb represent run-length binary number actual zero never encoded output lone zero becomes runa this step fact done time mtf whenever mtf would produce zero instead increase counter encode runa runb the sequence would represented runa runb runa runb represents value described the run-length code terminated reaching another normal symbol this rle process flexible initial rle step able encode arbitrarily long integer practice usually limited block size step encode run byte the run-length encoded fashion assigning place value first bit second third etc sequence multiply place value runb spot add resulting place value runa runb value alike together this similar bijective numeration thus sequence runa runb result value complicated example this process replaces fixed-length symbol range variable-length code based frequency use more frequently used code end shorter bit whilst rare code allocated bit the code selected carefully sequence bit confused different code the end-of-stream code particularly interesting different byte symbol used uncompressed data huffman code consist two rle code runa runb symbol code one end-of-stream code because combined result mtf rle encoding previous two step never need explicitly reference first symbol mtf table would zero ordinary mtf thus saving one symbol end-of-stream marker explaining symbol coded huffman tree extreme case one symbol used uncompressed data symbol code huffman tree entire block consist runa runb implicitly repeating single byte end-of-stream marker value several identically sized huffman table used block gain using greater cost including extra table least table present appropriate table reselected every symbol processed this advantage responsive huffman dynamic without continuously supply new table would required deflate run-length encoding previous step designed take care code inverse probability use higher shortest code huffman code use multiple huffman table use selection table numbered done list zero-terminated bit run bit length the selection mtf list table using feature result maximal expansion around generally le this expansion likely greatly over-shadowed advantage selecting appropriate huffman table common-case continuing use huffman table represented single bit rather unary encoding effectively extreme form huffman tree code half probability previous code huffman-code bit length required reconstruct used canonical huffman table each bit length stored encoded difference previous-code bit length zero bit mean previous bit length duplicated current code whilst one bit mean bit read bit length incremented decremented based value common case single bit used per symbol per table worst case—going length length require approximately bit result earlier mtf encoding code length would start bit long frequently used code gradually increase meaning delta format fairly efficient requiring around bit byte per full huffman table bitmap used show symbol used inside block included huffman tree binary data likely use symbol representable byte whereas textual data may use small subset available value perhaps covering ascii range storing zero bit would inefficient mostly unused sparse method used symbol divided range symbol used within block array included the presence range indicated additional bit array front the total bitmap us bit storage byte for contrast deflate algorithm would show absence symbol encoding symbol zero bit length run-length encoding additional huffman coding formal specification exists although informal specification reverse engineered reference implementation overview stream consists header followed zero compressed block immediately followed end-of-stream marker containing crc plaintext whole stream processed the compressed block bit-aligned padding occurs because first-stage rle compression see maximum length plaintext single block contain around byte this occur whole plaintext consists entirely repeated value resulting file case byte long even smaller file byte achieved using input containing entirely value apparent compression ratio the compressed block independently decompressed without process earlier block this mean file decompressed parallel making good format use big data application cluster computing framework like hadoop apache spark compress file effectively older lzw deflate .zip .gz compression algorithm considerably slower lzma generally space-efficient expense even slower compression speed much faster decompression compress data block size us burrows–wheeler transform convert frequently-recurring character sequence string identical letter applies move-to-front transform huffman coding ancestor bzip used arithmetic coding instead huffman the change made software patent restriction modern compressor share common ancestry set algorithm switched back arithmetic coding performance asymmetric decompression relatively fast motivated long time required compression modified version created called used multi-threading encode file multiple chunk giving almost linear speedup multi-cpu multi-core computer may update functionality incorporated main project like gzip data compressor archiver like tar zip program facility multiple file encryption archive-splitting unix tradition relies instead separate external utility tar gnupg task the grep-based bzgrep tool allows directly searching compressed text without needing uncompress content first